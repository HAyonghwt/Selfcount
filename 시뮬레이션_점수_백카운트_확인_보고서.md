# 시뮬레이션 점수 입력 후 전광판 백카운트 확인 보고서

## 확인 결과

### ✅ 백카운트 계산 로직 정상 작동

#### 1. 백카운트 계산 순서

**코스 순서 기반 정렬:**
```typescript
// 코스 순서대로 정렬 (order가 큰 것이 마지막 = 백카운트 기준)
allAssignedCoursesForPlayer.sort((a: any, b: any) => {
    // order 값에 따라 정렬 (작은 순서가 먼저)
    return numA - numB;
});

// 백카운트는 마지막 코스부터 역순이므로 reverse
const coursesForBackcount = [...finalCoursesForGroup].reverse();
```

**백카운트 진행 순서:**
1. **총타수 비교**: 동점이면 다음 단계
2. **코스별 점수 비교**: 마지막 코스부터 역순으로 비교
   - D코스 → C코스 → B코스 → A코스 순서
3. **홀별 점수 비교**: 각 코스에서 9번 홀부터 1번 홀까지 역순으로 비교
   - 9번 홀 → 8번 홀 → ... → 1번 홀

#### 2. `tieBreak` 함수 로직

```typescript
const tieBreak = (a: any, b: any, sortedCourses: any[]) => {
    // 1. 기권 처리 우선
    if (a.hasForfeited && !b.hasForfeited) return 1;
    if (!a.hasForfeited && b.hasForfeited) return -1;

    // 2. 점수 없음 처리
    if (!a.hasAnyScore && !b.hasAnyScore) return 0;
    if (!a.hasAnyScore) return 1;
    if (!b.hasAnyScore) return -1;

    // 3. 총타수 비교
    if (a.total !== b.total) {
        return a.total - b.total;
    }

    // 4. 코스별 점수 비교 (마지막 코스부터 역순)
    for (const course of sortedCourses) {
        const courseId = course.id;
        const aCourseScore = a.courseScores[courseId] || 0;
        const bCourseScore = b.courseScores[courseId] || 0;
        if (aCourseScore !== bCourseScore) {
            return aCourseScore - bCourseScore;
        }
    }

    // 5. 홀별 백카운트: 마지막 코스부터 역순으로 각 코스의 홀 점수 비교
    // 9번 홀부터 1번 홀까지 역순으로 비교
    for (const course of sortedCourses) {
        const courseId = course.id;
        const aHoleScores = a.detailedScores[courseId] || {};
        const bHoleScores = b.detailedScores[courseId] || {};
        
        for (let i = 9; i >= 1; i--) {
            const hole = i.toString();
            const aHole = aHoleScores[hole] || 0;
            const bHole = bHoleScores[hole] || 0;
            
            if (aHole !== bHole) {
                return aHole - bHole;
            }
        }
    }

    return 0; // 완전 동점
};
```

#### 3. 순위 계산 로직

```typescript
// 1. ±타수 기준 오름차순 정렬
playersWithPM.sort((a: any, b: any) => {
    if (a.cachedPM !== b.cachedPM) return a.cachedPM - b.cachedPM;
    return tieBreak(a, b, coursesForBackcount); // 백카운트 적용
});

// 2. 1위 동점자 처리: 최소 pm만 1위
// 3. 2위 이하부터 백카운트로 순위 부여
```

---

## 시뮬레이션 데이터 처리

### ✅ 시뮬레이션 데이터도 전광판에 표시됨

**확인 사항:**
- 전광판(`scoreboard/page.tsx`)에는 시뮬레이션 데이터 필터링이 **없음**
- 시뮬레이션 선수도 일반 선수와 동일하게 처리됨
- 백카운트 계산에도 시뮬레이션 선수가 포함됨

**시뮬레이션 선수 식별:**
- 이름에 "시뮬" 포함: `시뮬남자1`, `시뮬여자1` 등
- 소속에 "시뮬레이션" 포함

---

## 백카운트 계산 예시

### 시뮬레이션 데이터 예시

**선수 A (시뮬남자1):**
- A코스: 36타 (4,4,4,4,4,4,4,4,4)
- B코스: 36타 (4,4,4,4,4,4,4,4,4)
- C코스: 36타 (4,4,4,4,4,4,4,4,4)
- D코스: 36타 (4,4,4,4,4,4,4,4,4)
- **총타수: 144타**

**선수 B (시뮬남자2):**
- A코스: 36타 (4,4,4,4,4,4,4,4,4)
- B코스: 36타 (4,4,4,4,4,4,4,4,4)
- C코스: 36타 (4,4,4,4,4,4,4,4,4)
- D코스: 36타 (4,4,4,4,4,4,4,4,4)
- **총타수: 144타**

**백카운트 진행:**
1. 총타수 비교: 144타 = 144타 (동점)
2. 코스별 점수 비교:
   - D코스: 36타 = 36타 (동점)
   - C코스: 36타 = 36타 (동점)
   - B코스: 36타 = 36타 (동점)
   - A코스: 36타 = 36타 (동점)
3. 홀별 점수 비교 (D코스부터):
   - D코스 9번 홀: 4타 = 4타 (동점)
   - D코스 8번 홀: 4타 = 4타 (동점)
   - ... (모든 홀이 동점이면 다음 코스로)
   - C코스 9번 홀: 4타 = 4타 (동점)
   - ... (계속 비교)

---

## 코스 순서 검증

### ✅ 코스 순서 검증 로직 존재

```typescript
const validateCourseOrder = (coursesForGroup: any[], coursesOrder: any, groupName: string) => {
    // 1. order 값이 없는 코스 확인
    // 2. order 값 중복 확인
    // 3. 경고 메시지 생성
};
```

**검증 항목:**
1. **order 값 없음**: 코스에 순서 정보가 없으면 경고
2. **order 값 중복**: 같은 order 값을 가진 코스가 있으면 경고
3. **자동 처리**: order가 없는 코스는 자동으로 뒤로 이동

---

## 결론

### ✅ 백카운트 계산 정상 작동

1. **시뮬레이션 데이터 포함**: 시뮬레이션 선수도 전광판에 표시되고 백카운트 계산에 포함됨
2. **백카운트 로직 정확**: 코스 순서와 홀 순서가 올바르게 적용됨
3. **순위 계산 정확**: ±타수 기준 정렬 후 백카운트로 동점 해결
4. **코스 순서 검증**: order 값 검증 로직이 있어 데이터 무결성 보장

### 확인 사항

- ✅ 시뮬레이션 점수가 전광판에 표시됨
- ✅ 백카운트 계산에 시뮬레이션 선수 포함됨
- ✅ 코스 순서대로 백카운트 진행됨
- ✅ 홀 순서대로 백카운트 진행됨 (9번 → 1번)
- ✅ 동점 해결 로직 정상 작동

### 권장 사항

현재 상태로도 정상 작동하지만, 시뮬레이션 데이터를 전광판에서 숨기고 싶다면:

```typescript
// processedDataByGroup useMemo 내부에 필터 추가
const allProcessedPlayers: any[] = playersToProcess
    .filter(([playerId, player]: [string, any]) => {
        // 시뮬레이션 데이터 제외
        return !player.name?.includes('시뮬') && !player.affiliation?.includes('시뮬');
    })
    .map(([playerId, player]: [string, any]) => {
        // ... 기존 로직
    });
```

하지만 현재는 시뮬레이션 데이터도 전광판에 표시되어 백카운트가 정상적으로 계산되고 있습니다.

